<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­åœŸæ˜Ÿï¼ˆé¼ æ ‡+æ‰‹åŠ¿åŒæ§åˆ¶ï¼‰</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            color: white;
            cursor: grab; /* é¼ æ ‡æ ·å¼æç¤ºå¯æ‹–åŠ¨ */
        }
        body:active {
            cursor: grabbing; /* æ‹–åŠ¨æ—¶é¼ æ ‡æ ·å¼ */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #050505 0%, #0b0b10 100%);
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
            pointer-events: none;
        }

        .glass-panel {
            background: rgba(5, 5, 5, 0.7);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 2px;
            border-left: 2px solid #c5a059;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            max-width: 280px;
        }

        h1 {
            font-weight: 200;
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #e0cda7;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .status-text {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.6;
            font-family: monospace;
        }

        .highlight {
            color: #c5a059;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            pointer-events: auto;
        }

        #author-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            z-index: 20;
            pointer-events: auto;
            text-decoration: none;
            color: #c5a059;
            border: 1px solid rgba(197, 160, 89, 0.4);
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 20px;
            font-size: 0.8rem;
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            letter-spacing: 1px;
            font-family: monospace;
        }

        #author-btn:hover {
            background: #c5a059;
            color: #000;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.4);
        }

        button {
            background: transparent;
            border: 1px solid rgba(197, 160, 89, 0.3);
            color: #c5a059;
            padding: 12px 30px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            background: rgba(197, 160, 89, 0.1);
            border-color: #c5a059;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        #fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-family: monospace;
            font-size: 10px;
            z-index: 5;
        }

        .input_video { display: none; }

        /* æ–°å¢ï¼šæ§åˆ¶æç¤ºæ–‡æœ¬ */
        #control-tips {
            position: absolute;
            bottom: 20px;
            left: 30px;
            z-index: 10;
            font-size: 0.7rem;
            color: #888;
            font-family: monospace;
            pointer-events: none;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <video class="input_video"></video>

    <a id="author-btn" href="https://www.yjln.com" target="_blank">By Mr.lun</a> <!-- è¿™æ˜¯åŸä½œè€… -->
    <!-- è¿™ä¸ªç‰ˆæœ¬çš„ä»£ç åœ¨ç½‘é¡µï¼šhttps://github.com/notcharlatan/litttleToys/blob/main/%E6%89%8B%E6%8E%A7%E7%B2%92%E5%AD%90%E5%9C%9F%E6%98%9F.html -->

    <div id="fps-counter">ç‰©ç†å¼•æ“: æè‡´æ¨¡å¼ | ç¯å¢ƒ: å¤ªé˜³ç³»æ¨¡æ‹Ÿ</div>

    <div id="loading">
        æ­£åœ¨æ„å»ºç™¾ä¸‡ç²’å­ä¸è¡Œæ˜Ÿæ•°æ®...
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>åœŸæ˜Ÿ</h1>
            <div class="status-text">
                æ•°æ®æµçŠ¶æ€: <span id="status-indicator" class="highlight">å¾…æœº</span>
                <br><br>
                > å¼€æ™®å‹’è½¨é“: è¿è¡Œä¸­<br>
                > ç²’å­æ€»æ•°: 120ä¸‡+<br>
                > èƒŒæ™¯ç¯å¢ƒ: è¡Œæ˜Ÿå·²åŠ è½½
            </div>
        </div>
    </div>

    <!-- æ–°å¢ï¼šæ§åˆ¶æç¤ºï¼ˆè¡¥å……Xè½´æ—‹è½¬è¯´æ˜ï¼‰ -->
    <div id="control-tips">
        ğŸ–±ï¸ é¼ æ ‡æ»šè½® = ç¼©æ”¾ | é¼ æ ‡ä¸Šä¸‹æ‹–åŠ¨ = ä¿¯ä»° | é¼ æ ‡å·¦å³æ‹–åŠ¨ = ç»•Yè½´æ—‹è½¬<br>
        âœ‹ æ‰‹åŠ¿ = åŒæ­¥æ§åˆ¶ï¼ˆç¼©æ”¾+ä¿¯ä»°ï¼‰
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">å…¨å±æ²‰æµ¸ä½“éªŒ</button>
    </div>

    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float opacityAttr;
        attribute float orbitSpeed;
        attribute float isRing;
        attribute float aRandomId;

        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;

        uniform float uTime;
        uniform float uScale;
        uniform float uRotationX;
        uniform float uRotationY; // ========== æ–°å¢ï¼šYè½´æ—‹è½¬uniform ==========

        mat2 rotate2d(float _angle){
            return mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle));
        }

        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            float normScaleLOD = clamp((uScale - 0.15) / 2.35, 0.0, 1.0);
            float visibilityThreshold = 0.9 + pow(normScaleLOD, 1.2) * 0.1;

            if (aRandomId > visibilityThreshold) {
                gl_Position = vec4(0.0);
                gl_PointSize = 0.0;
                return;
            }

            vec3 pos = position;

            if (isRing > 0.5) {
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            }

            // ========== æ–°å¢ï¼šå…ˆå¤„ç†ç»•Yè½´æ—‹è½¬ ==========
            float cy = cos(uRotationY);
            float sy = sin(uRotationY);
            float rx = pos.x * cy + pos.z * sy;
            float rz = -pos.x * sy + pos.z * cy;
            pos.x = rx;
            pos.z = rz;

            // åŸæœ‰ï¼šç»•Xè½´ä¿¯ä»°æ—‹è½¬
            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            rz = pos.y * sx + pos.z * cx;
            pos.y = ry;
            pos.z = rz;

            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            float chaosThreshold = 25.0;
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);

                float highFreqTime = uTime * 40.0;
                float noiseX = sin(highFreqTime + pos.x * 10.0) * hash(pos.y);
                float noiseY = cos(highFreqTime + pos.y * 10.0) * hash(pos.x);
                float noiseZ = sin(highFreqTime * 0.5) * hash(pos.z);

                vec3 noiseVec = vec3(noiseX, noiseY, noiseZ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }

            gl_Position = projectionMatrix * mvPosition;

            float pointSize = size * (350.0 / dist);
            pointSize *= 0.55;

            if (isRing < 0.5 && dist < 50.0) {
                 pointSize *= 0.8;
            }

            gl_PointSize = clamp(pointSize, 0.0, 300.0);

            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;

        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            float glow = smoothstep(1.0, 0.4, r);

            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);

            vec3 deepGold = vec3(0.35, 0.22, 0.05);
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);

            float brightness = 0.2 + 1.0 * t;

            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);

            vec3 finalColor = baseColor * brightness;

            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);

                if (vIsRing < 0.5) {
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5;
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }

            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);

            float alpha = glow * vOpacity * densityAlpha * depthAlpha;

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uTime;

        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            gl_PointSize = size * (1000.0 / dist);
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor;
        uniform float uTime;
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);

            float glow = 1.0 - r;
            glow = pow(glow, 1.5);

            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <script type="x-shader/x-vertex" id="planetVertexShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="planetFragmentShader">
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float noiseScale;
        uniform vec3 lightDir;
        uniform float atmosphere;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < 5; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);

            vec3 normal = normalize(vNormal);
            vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05);

            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);

            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;

        let targetScale = 1.0;
        let targetRotX = 0.4;
        let currentScale = 1.0;
        let currentRotX = 0.4;

        // ========== æ–°å¢ï¼šYè½´æ—‹è½¬ç›¸å…³å˜é‡ ==========
        let targetRotY = 0.0;    // Yè½´æ—‹è½¬ç›®æ ‡å€¼
        let currentRotY = 0.0;   // Yè½´æ—‹è½¬å½“å‰å€¼
        const rotYStep = 0.005;  // Yè½´æ—‹è½¬æ­¥é•¿ï¼ˆå’ŒXè½´ä¿æŒä¸€è‡´ï¼Œä¿è¯æ‰‹æ„Ÿç»Ÿä¸€ï¼‰

        let isHandDetected = false;

        // é¼ æ ‡æ§åˆ¶ç›¸å…³å˜é‡ï¼ˆè¡¥å……Xè½´ï¼‰
        let isMouseDown = false;
        let lastMouseX = 0;         // æ–°å¢ï¼šè®°å½•é¼ æ ‡Xè½´åˆå§‹ä½ç½®
        let lastMouseY = 0;
        const scaleStep = 0.08;
        const rotStep = 0.005;

        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status-indicator');
        const loadingElement = document.getElementById('loading');

        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.00015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            initSaturn();
            initStarfield();
            initPlanets();

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // é¼ æ ‡äº‹ä»¶ï¼ˆè¡¥å……Xè½´é€»è¾‘ï¼‰
            document.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                lastMouseX = e.clientX; // æ–°å¢ï¼šè®°å½•é¼ æ ‡Xåˆå§‹ä½ç½®
                lastMouseY = e.clientY;
            });

            document.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    // Xè½´åç§»ï¼šæ§åˆ¶ç»•Yè½´æ—‹è½¬
                    const deltaX = e.clientX - lastMouseX;
                    targetRotY += deltaX * rotYStep; // å·¦å³æ‹–åŠ¨ â†’ ç»•Yè½´æ—‹è½¬
                    // è§£é™¤Yè½´æ—‹è½¬èŒƒå›´é™åˆ¶ï¼ˆæ”¯æŒ360Â°æ— é™æ—‹è½¬ï¼‰ï¼Œä¹Ÿå¯åŠ é™åˆ¶ï¼štargetRotY = Math.max(-Math.PI, Math.min(Math.PI, targetRotY + deltaX * rotYStep));
                    lastMouseX = e.clientX; // æ›´æ–°Xè½´åˆå§‹ä½ç½®

                    // Yè½´åç§»ï¼šæ§åˆ¶ç»•Xè½´ä¿¯ä»°
                    const deltaY = e.clientY - lastMouseY;
                    targetRotX = Math.max(-0.6, Math.min(1.0, targetRotX + deltaY * rotStep));
                    lastMouseY = e.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    targetScale = Math.min(2.5, targetScale + scaleStep);
                } else {
                    targetScale = Math.max(0.15, targetScale - scaleStep);
                }
            }, { passive: false });

            animate();
        }

        function initSaturn() {
            const particleCount = 1200000;
            const geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);
            const randomIds = new Float32Array(particleCount);

            const bodyColors = [
                new THREE.Color('#E3DAC5'),
                new THREE.Color('#C9A070'),
                new THREE.Color('#E3DAC5'),
                new THREE.Color('#B08D55')
            ];

            const colorRingC = new THREE.Color('#2A2520');
            const colorRingB_Inner = new THREE.Color('#CDBFA0');
            const colorRingB_Outer = new THREE.Color('#DCCBBA');
            const colorCassini = new THREE.Color('#050505');
            const colorRingA = new THREE.Color('#989085');
            const colorRingF = new THREE.Color('#AFAFA0');

            const R_PLANET = 18;

            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size, opacity, speed, isRingVal;
                randomIds[i] = Math.random();

                if (i < particleCount * 0.25) {
                    isRingVal = 0.0;
                    speed = 0.0;
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const rad = R_PLANET;

                    x = rad * Math.sin(phi) * Math.cos(theta);
                    let rawY = rad * Math.cos(phi);
                    z = rad * Math.sin(phi) * Math.sin(theta);

                    y = rawY * 0.9;

                    let lat = (rawY / rad + 1.0) * 0.5;
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseCol = bodyColors[colIndex];

                    r = baseCol.r; g = baseCol.g; b = baseCol.b;
                    size = 1.0 + Math.random() * 0.8;
                    opacity = 0.8;
                } else {
                    isRingVal = 1.0;
                    let zoneRand = Math.random();
                    let ringRadius;
                    let ringCol;

                    if (zoneRand < 0.15) {
                        ringRadius = R_PLANET * (1.235 + Math.random() * (1.525 - 1.235));
                        ringCol = colorRingC;
                        size = 0.5; opacity = 0.3;
                    } else if (zoneRand < 0.65) {
                        let t = Math.random();
                        ringRadius = R_PLANET * (1.525 + t * (1.95 - 1.525));
                        ringCol = colorRingB_Inner.clone().lerp(colorRingB_Outer, t);
                        size = 0.8 + Math.random() * 0.6; opacity = 0.85;
                        if (Math.sin(ringRadius * 2.0) > 0.8) opacity *= 1.2;
                    } else if (zoneRand < 0.69) {
                        ringRadius = R_PLANET * (1.95 + Math.random() * (2.025 - 1.95));
                        ringCol = colorCassini;
                        size = 0.3; opacity = 0.1;
                    } else if (zoneRand < 0.99) {
                        ringRadius = R_PLANET * (2.025 + Math.random() * (2.27 - 2.025));
                        ringCol = colorRingA;
                        size = 0.7; opacity = 0.6;
                        if (ringRadius > R_PLANET * 2.2 && ringRadius < R_PLANET * 2.21) opacity = 0.1;
                    } else {
                        ringRadius = R_PLANET * (2.32 + Math.random() * 0.02);
                        ringCol = colorRingF;
                        size = 1.0; opacity = 0.7;
                    }

                    const theta = Math.random() * Math.PI * 2;
                    x = ringRadius * Math.cos(theta);
                    z = ringRadius * Math.sin(theta);

                    let thickness = 0.15;
                    if (ringRadius > R_PLANET * 2.3) thickness = 0.4;
                    y = (Math.random() - 0.5) * thickness;

                    r = ringCol.r; g = ringCol.g; b = ringCol.b;

                    speed = 8.0 / Math.sqrt(ringRadius);
                }

                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
                sizes[i] = size; opacities[i] = opacity;
                orbitSpeeds[i] = speed; isRings[i] = isRingVal;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));
            geometry.setAttribute('aRandomId', new THREE.BufferAttribute(randomIds, 1));

            uniforms = {
                uTime: { value: 0 },
                uScale: { value: 1.0 },
                uRotationX: { value: 0.4 },
                uRotationY: { value: 0.0 } // ========== æ–°å¢ï¼šYè½´æ—‹è½¬uniform ==========
            };

            const material = new THREE.ShaderMaterial({
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180);
            scene.add(particles);
        }

        function initStarfield() {
            const starCount = 50000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3);
            const cols = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            const starColors = [
                new THREE.Color('#9bb0ff'), new THREE.Color('#ffffff'),
                new THREE.Color('#ffcc6f'), new THREE.Color('#ff7b7b')
            ];

            for(let i=0; i<starCount; i++) {
                const r = 400 + Math.random() * 3000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);

                const colorType = Math.random();
                let c;
                if(colorType > 0.9) c = starColors[0]; else if(colorType > 0.6) c = starColors[1];
                else if(colorType > 0.3) c = starColors[2]; else c = starColors[3];

                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = 1.0 + Math.random() * 3.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            starUniforms = { uTime: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: document.getElementById('starFragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            const nebulaCount = 100;
            const nebGeo = new THREE.BufferGeometry();
            const nebPos = new Float32Array(nebulaCount * 3);
            const nebCols = new Float32Array(nebulaCount * 3);
            const nebSizes = new Float32Array(nebulaCount);
            for(let i=0; i<nebulaCount; i++) {
                const r = 800 + Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.PI / 2 + (Math.random() - 0.5) * 1.5;
                nebPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                nebPos[i*3+1] = r * Math.cos(phi);
                nebPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                const nc = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.8, 0.05);
                nebCols[i*3] = nc.r; nebCols[i*3+1] = nc.g; nebCols[i*3+2] = nc.b;
                nebSizes[i] = 400.0 + Math.random() * 600.0;
            }
            nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3));
            nebGeo.setAttribute('customColor', new THREE.BufferAttribute(nebCols, 3));
            nebGeo.setAttribute('size', new THREE.BufferAttribute(nebSizes, 1));
            const nebShaderMat = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        if(r > 1.0) discard;
                        float glow = pow(1.0 - r, 2.0);
                        gl_FragColor = vec4(vColor, glow * 0.1);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            nebula = new THREE.Points(nebGeo, nebShaderMat);
            scene.add(nebula);
        }

        function initPlanets() {
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            const vShader = document.getElementById('planetVertexShader').textContent;
            const fShader = document.getElementById('planetFragmentShader').textContent;

            createPlanet(planetGroup, vShader, fShader,
                new THREE.Color('#b33a00'), new THREE.Color('#d16830'), 8.0,
                { x: -300, y: 120, z: -450 }, 10, 0.3
            );

            createPlanet(planetGroup, vShader, fShader,
                new THREE.Color('#001e4d'), new THREE.Color('#ffffff'), 5.0,
                { x: 380, y: -100, z: -600 }, 14, 0.6
            );

            createPlanet(planetGroup, vShader, fShader,
                new THREE.Color('#666666'), new THREE.Color('#aaaaaa'), 15.0,
                { x: -180, y: -220, z: -350 }, 6, 0.1
            );
        }

        function createPlanet(group, vShader, fShader, c1, c2, nScale, pos, radius, atmo) {
            const geo = new THREE.SphereGeometry(radius, 48, 48);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    color1: { value: c1 },
                    color2: { value: c2 },
                    noiseScale: { value: nScale },
                    lightDir: { value: new THREE.Vector3(1, 0.5, 1) },
                    atmosphere: { value: atmo }
                },
                vertexShader: vShader,
                fragmentShader: fShader
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            group.add(mesh);
        }

        const clock = new THREE.Clock();
        let autoIdleTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            uniforms.uTime.value = elapsedTime;
            if(starUniforms) starUniforms.uTime.value = elapsedTime;

            if(stars) stars.rotation.y = elapsedTime * 0.005 + currentRotY * 0.5; // èƒŒæ™¯æ˜Ÿæ˜Ÿè·ŸéšYè½´æ—‹è½¬ï¼ˆè½»å¾®è§†å·®ï¼‰
            if(nebula) nebula.rotation.y = elapsedTime * 0.003 + currentRotY * 0.3; // æ˜Ÿäº‘è·ŸéšYè½´æ—‹è½¬

            if(planetGroup) {
                planetGroup.children.forEach((planet, idx) => {
                    planet.rotation.y = elapsedTime * (0.05 + idx * 0.02);
                });
                planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02 + currentRotY * 0.2; // èƒŒæ™¯è¡Œæ˜Ÿè·ŸéšYè½´æ—‹è½¬
            }

            // è‡ªåŠ¨å·¡èˆªé€»è¾‘ï¼šä»…å½“æ— æ‰‹åŠ¿+æ— é¼ æ ‡æ“ä½œæ—¶ç”Ÿæ•ˆ
            const isMouseActive = isMouseDown || (targetScale !== 1.0 || targetRotX !== 0.4 || targetRotY !== 0.0);
            if (!isHandDetected && !isMouseActive) {
                autoIdleTime += 0.005;
                targetScale = 1.0 + Math.sin(autoIdleTime) * 0.2;
                targetRotX = 0.4 + Math.sin(autoIdleTime * 0.3) * 0.15;
                targetRotY = Math.sin(autoIdleTime * 0.2) * 0.8; // è‡ªåŠ¨å·¡èˆªæ—¶ç¼“æ…¢ç»•Yè½´æ—‹è½¬

                statusElement.innerHTML = "ç³»ç»ŸçŠ¶æ€: è‡ªåŠ¨å·¡èˆª<br>è¾“å…¥ä¿¡å·: ç­‰å¾…ä¸­...";
                statusElement.style.color = "#666";
            } else if (isHandDetected) {
                statusElement.innerHTML = "ç³»ç»ŸçŠ¶æ€: æ‰‹åŠ¿æ§åˆ¶<br>è¾“å…¥ä¿¡å·: <span class='highlight'>å·²é”å®š</span>";
                statusElement.style.color = "#c5a059";
            } else if (isMouseActive) {
                statusElement.innerHTML = "ç³»ç»ŸçŠ¶æ€: é¼ æ ‡æ§åˆ¶<br>è¾“å…¥ä¿¡å·: <span class='highlight'>å·²é”å®š</span>";
                statusElement.style.color = "#87ceeb";
            }

            // å¹³æ»‘æ’å€¼ï¼ˆè¡¥å……Yè½´ï¼‰
            const lerpFactor = 0.08;
            currentScale += (targetScale - currentScale) * lerpFactor;
            currentRotX += (targetRotX - currentRotX) * lerpFactor;
            currentRotY += (targetRotY - currentRotY) * lerpFactor; // æ–°å¢ï¼šYè½´æ—‹è½¬å¹³æ»‘æ’å€¼

            // åº”ç”¨æ‰€æœ‰uniform
            uniforms.uScale.value = currentScale;
            uniforms.uRotationX.value = currentRotX;
            uniforms.uRotationY.value = currentRotY; // æ–°å¢ï¼šä¼ é€’Yè½´æ—‹è½¬å€¼åˆ°ç€è‰²å™¨

            renderer.render(scene, camera);
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        function onResults(results) {
            loadingElement.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const hand = results.multiHandLandmarks[0];

                // æ‰‹åŠ¿æ§åˆ¶ç¼©æ”¾
                const p1 = hand[4];
                const p2 = hand[8];
                const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                targetScale = 0.15 + normDist * 2.35;

                // æ‰‹åŠ¿æ§åˆ¶ä¿¯ä»°ï¼ˆXè½´ï¼‰
                const y = hand[9].y;
                const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                targetRotX = -0.6 + normY * 1.6;

                // å¯é€‰ï¼šå¦‚æœéœ€è¦æ‰‹åŠ¿æ§åˆ¶Yè½´æ—‹è½¬ï¼Œå¯æ·»åŠ æ‰‹æŒXè½´ä½ç½®æ£€æµ‹
                const x = hand[9].x;
                const normX = Math.max(0, Math.min(1, (x - 0.1) / 0.8));
                targetRotY = -Math.PI + normX * Math.PI * 2;

            } else {
                isHandDetected = false;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start().catch(e => {
            console.error(e);
            loadingElement.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥";
        });

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }

        initThree();

    </script>
</body>
</html>